<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>20210407错题</title>
</head>
<body>
    <script>
        // ********************* 1 ************************
        // javascript中实现跨域的方式总结
        // 第一种方式：jsonp请求；jsonp的原理是利用<script>标签的跨域特性，可以不受限制地从其他域中加载资源，类似的标签还有<img>.为get请求
        // 第二种方式：document.domain；这种方式用在主域名相同子域名不同的跨域访问中
        // 第三种方式：window.name；window的name属性有个特征：在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。
        // 第四种方式：window.postMessage；window.postMessages是html5中实现跨域访问的一种新方式，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源。
        // 第五种方式：CORS；CORS背后的基本思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是应该失败。
        // 第六种方式：Web Sockets；web sockets原理：在JS创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。


        // ********************* 2 ************************
        // reflow(回流)和repaint(重绘)

        // 简要：整个在浏览器的渲染过程中（页面初始化，用户行为改变界面样式，动画改变界面样式等）reflow(回流)和repaint(重绘) 会大大影响web性能，尤其是手机页面。因此我们在页面设计的时候要尽量减少reflow和repaint。

        // 什么是reflow和repaint（原文链接：http://www.cnblogs.com/Peng2014/p/4687218.html）

        
        
        // Reflow：当render树的一部分或者全部因为大小边距等问题发生改变而需要重建的过程，叫做回流。

        // reflow：例如某个子元素样式发生改变，直接影响到了其父元素以及往上追溯很多祖先元素（包括兄弟元素），这个时候浏览器要重新去渲染这个子元素相关联的所有元素的过程称为回流。

        // reflow：几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。
        
        
        // Repaint(重绘)：当诸如颜色背景等不会引起页面布局变化，而只需要重新渲染的过程叫做重绘。
        // repaint：如果只是改变某个元素的背景色、文 字颜色、边框颜色等等不影响它周围或内部布局的属性，将只会引起浏览器 repaint（重绘）。repaint 的速度明显快于 reflow

        // 下面情况会导致reflow发生

        // 1：改变窗口大小

        // 2：改变文字大小

        // 3：内容的改变，如用户在输入框中敲字

        // 4：激活伪类，如:hover

        // 5：操作class属性

        // 6：脚本操作DOM

        // 7：计算offsetWidth和offsetHeight

        // 8：设置style属性



        // ********************* 3 ************************
        // Array.from(arr, mapfn,thisArg)方法，用于将两类可以把对象转换为真正的数组：类似数组的对象和可遍历的对象（部署了Iterator接口的，String，ES6新增的Map和Set）。可以传3个参数，其中第一个是数组，必传；第二个是一个函数（类似map函数），对数组元素进行操作后再返回数组，可选；第三个是对于this关键字的指向，可选。
        // slice() 方法可从已有的数组中返回选定的元素。
        // 返回值：返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。
        // 说明
        // 请注意，该方法并不会修改数组，而是返回一个子数组。如果想删除数组中的一段元素，应该使用方法 Array.splice()。
        // 所以在这里就是对集合A应用slice，返回一个新的数组，不对数组做任何改变。
        // 展开运算符，把A集合的元素展开后，用数组[]承载，返回新的数组。
        // map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。
        // map() 方法按照原始数组元素顺序依次处理元素。
        // 注意： map() 不会对空数组进行检测。
        // 注意： map() 不会改变原始数组。
        // 所以map方法返回了一个新的数组，并且数组中每个元素是A里面的元素。



        // ********************* 4 ************************
        // AMD是"Asynchronous Module Definition"的缩写，意思就是"异步模块定义"。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。
        // AMD也采用require()语句加载模块，但是不同于CommonJS。
        // 主要有两个Javascript库实现了AMD规范：require.js和curl.js。
        // 参考链接：http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html

        // AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。
        // CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。
        // 区别：
        // 1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。
        // 2. CMD 推崇依赖就近，AMD 推崇依赖前置。

        
    </script>
</body>